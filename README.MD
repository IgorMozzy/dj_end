### BB Итоговый проект
_Проект представляет собой веб-сайт со списком фильмов. Реализована функциональность для добавления новых фильмов (администратор), просмотра информации о текущих, их оценивание и рецензирование (пользователи), удаления или редактирования рецензий (модераторы)._

### Используемые технологии:
* **Django**
* **DRF**
* **HTML/CSS+Bootstrap**
* **Docker+Docker Compose**
* **Nginx**
* **GitHub Actions**

### Состав проекта
Реализованы следующие Django приложения:
1. Users - модели пользователей, логика регистрации и аутентификации (постмиграция гарантирует наличие групп Admins, Moderators, Users)
2. API - DRF эндпоинты для работы с пользователями (создание удаление, получение JWT токенов). _На текущий момент поддержка только работы с пользователями и группами, но не фильмами._
3. Movies - Основное приложение, включающее в себя модели для работы с базой фильмов и django templates для отображения

### Управление пользователями
Признаком администратором считается системная роль is_staff, группы Admins и Users могут использованы для разграничения доступа к представлениям.

#### С использованием DRF и JWT (через JWT реализована аутинтификация в API):
`/api/token/ - {"username": "username", "password": "string"}
Получениу Access и Refresh токенов по данным для авторизации
/api/refresh/ - {"refresh": "string"}
Получение Access токена по Refresh токену`

Для получения информации по группам и пользователям:

`/groups/ - GET, POST,
/groups/{id}/ - GET, PUT, PATCH, DELETE
/users/ - GET, POST
/users/{id}/ - GET, PUT, PATCH, DELETE
Возможные параметры для методов можно увидеть в документации:
/swagger/ - swagger с автодокументацией и возможностью тестирования (доступнен администраторам)
/swagger.json - схема в json`

#### Установка
1. В репозитарии настроен автоматическое тестирование и деплой через GitHub Actions с конфигом, предполагающим разварачивание на сервере с linux и возможностью установки docker+compose.
2. Скрипт установки требует задания в Secrets репозитария параметров SSH_HOST, SSH_PRIVATE_KEY, SSH_USERNAME - для подключения в процессе автоматизированного деплоя к указанной машине по SSH
3. Для успешного подключения в процессе деплоя сервер должен будет подключиться к репозитарию, что также может потребовать (если реп. приватный) наличия на сервере приватной части ключа (с публичной, добавленной в настройки аккаунта гитхаба для авторизации.)
4. При необходимости можно предварительно проверить авторизацию с сервера на GitHub: ssh -T git@github.com
5. После самого первого деплоя необходимо скопировать сертификат SSL на сервер, их сертификатов заданы в конфиге nginx, по умолчанию cert.crt cert.key
6. Скорректировать настройки .env файла в папке проекта на сервере: добавить secret key, allowed hosts и DJANGO_CSRF_TRUSTED_ORIGINS (через запятую), например:

    DJANGO_ALLOWED_HOSTS=localhost,127.0.0.1,web,158.160.26.232,somedomain.ru

    DJANGO_CSRF_TRUSTED_ORIGINS=https://somedomain.ru,http://somedomain.ru

7. Пересобрать контейнеры docker compose up -d --build
8. Либо на предыдущем шаге можно скорректировать настройки nginx, удалив пути к файлам сертификатов.
9. Дальнейшие апдейты необходимо делать непосредственно через репозитарий, чтобы не возникало конфликтов при слиянии. На текущий момент branch для клонирования указывается вручную в .github\workflows\ci_cd.yaml
10. После первоначального деплоя также нужно сконфигурировать Grafana, использовав для первого входа дефолтный пароль из переменных окружения. Она доступна на порту 3000 по ip хоста через http.
11. Сервер prometheus может быть добавлен в Grafana по пути http://prometheus:9090
12. Первого суперпользователя можно создать в контейнере web: docker compose exec web bash, затем python3 manage.py createsuperuser
13. При необходимости заполнения базы тестовыми данными можно использовать python manage.py seed_data - используется скр movies/management/seed_data.py

Примеры команд, используемых в процессе
scp -i ./.ssh/key "C:\Users\..." name@IP:<destination path> - копирование ключей
ssh -i ./.ssh/key name@IP - ssh с использованием конкр. ключа
python -c "from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())" - генерация секретного ключа в джанго
